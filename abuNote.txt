




/////////////////////////////////////////////////////////////
git - android studio教程 :http://my.oschina.net/u/2367628/blog/508283
git:
http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/00137396287703354d8c6c01c904c7d9ff056ae23da865a000
http://blog.csdn.net/god_wot/article/details/10522405
http://www.cnblogs.com/alanalan/archive/2012/09/17/2689747.html


本地文件夹创建版本库

git branch --set-upstream master origin/master

$ git init

本地文件的预加载 和 说明 和提交
$ git add file1.txt
$ git add file2.txt file3.txt
$ git commit -m "add 3 files."

远程仓库创建与关联 创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：
$ ssh-keygen -t rsa -C "youremail@example.com"
你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。
如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。
第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：
然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容：

关联版本库
$ git remote add origin git@github.com:bulasuo/abuHttp.git

把远程厂库更新到此
$ git pull origin master

提交本地版本到远程版本库
$ git push -u origin master 或者 $ git push origin master

clone 远程版本库  到父目录clone到子目录(远程库)
$ git clone git@github.com:bulasuo/abuNote.git

已经有remote地址 可以
$ git remote rm origin清除

Git鼓励大量使用分支：
查看分支：git branch
创建分支：git branch <name>
切换分支：git checkout <name>
创建+切换分支：git checkout -b <name>
合并某分支到当前分支：git merge <name>
删除分支：git branch -d <name>

标签TAG:
命令git tag <name>用于新建一个标签，默认为HEAD，也可以指定一个commit id；
git tag -a <tagname> -m "blablabla..."可以指定标签信息；
git tag -s <tagname> -m "blablabla..."可以用PGP签名标签；
git tag可以查看所有标签。
git push origin <tagname>可以推送一个本地标签；
git push origin --tags可以推送全部未推送过的本地标签；
git tag -d <tagname>可以删除一个本地标签；
git push origin :refs/tags/<tagname>可以删除一个远程标签。
git checkout <tag>回退到tag的代码 但是要注意当前代码可能会丢失(切换到tag历史记录会处在分离头指针状态，这个是的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b tset v0.1.0  这个时候就会在分支上进行开发，之后可以切换到主线合并)

git版本回退
HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。
穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。
要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。

/////////////////////////////////////////////////////////////////////////////////////////

   /**
     * Enable extended support library window features.
     * <p>
     * This is a convenience for calling
     * {@link android.view.Window#requestFeature getWindow().requestFeature()}.
     * </p>
     *
     * @param featureId The desired feature as defined in
     * {@linkplain android.view.Window#requestFeature} or {@link android.support.v4.view.WindowCompat}.
     * @return Returns true if the requested feature is supported and now enabled.
     *
     * @see android.app.Activity#requestWindowFeature
     * @see android.view.Window#requestFeature
     */


android事件分发:
viewGroup的onInterceptTouchEvent（是否拦截）-子View的dispatchTouchEvent（是否消费）-onTouch（是否消费）-onTouchEvent（是否消费）-onClick

MVP M设计成单例  P设计成单例  V本身作为参数调用P  P回调V ；P本身作为参数调用M   M回调P  . 现有逻辑x ，1设计Mx处理x，2设计接口Ix 定义Mx回调的方法同时也是V要实现的接口，3Ix作为Mx处理x的方法的参数 ，4P本身实现Ix，本身作为参数调用Mx

一个activityattach了多个Fragment后,Fragment的onResume会随activity的onResume而触发 不管是不是isHidden;所以在Fragment的 onResume里如果弹出键盘 要判断是不是 ishidden;
而Fragment的show 和 hidden  不会触发 onResume 等生命周期 但会触发onHidden
所以在onHidden里调用onResume 基本可以实现 和activity一样的逻辑

数据加载重要逻辑原则:数据标志位的重要性 && NullPointException进行异常捕获(特别是不确定是数据,比如网络请求来的数据,一定要空指针异常捕获)
不显示数据到UI可以依据 1.数据为空 2.数据标志位为不显示
显示数据到UI 一定要是 1.数据不为空 且 2.数据标志位为显示
(就是说要显示到UI 一定要有标志位 为显示,仅仅依靠数据为不为null  可能数据的子数据为null,所以一定要对NullPointException进行异常捕获)

RecycleView的总结:
JsonObject.get("city_name")当该字段为null 它可能不为null 但是把它打印出来System.out.println(JsonObject.get("city_name"));结果是null 并且JsonObject.get("city_name").getAsString会报异常,所以这种应该尽量将JsonObject转换为Bean对象使用,或者在 onBindViewHolder(CoreViewHolder holder, int position) 最外面一层加个try{},不然的话一有异常RecycleView就会不正常具体表现是数据混乱,显示不正常.或者不要用JsonObject.get("city_name").getAsString而用JsonObject.get("city_name").toString.replace("\"", "");这里一定要注意 以后取值  要注意null空异常 或者在最外面加个try{}把业务上不应该为null的打印出来


泛型类的优势:
比如写了一个CallBack类是用泛型的,当用到改类的时候已经指定了类型参数,所以可以在该CallBack类里面对回调方法传的参数进行ClassCaseException异常捕获
而如果没有指定泛型,那就要在每个实现该回调方法的地方进行ClassCaseException异常捕获,这样非常繁琐.

ui 更新 不要调用 网络请求
网络请求 在 用户点击 或者 广播接收处 调用
每个网络请求  发送精确描述改 请求结果的 message.what
每个 广播接收处 要注册 改页面 需要接收的 精确描述的 message.what
页面数据放在arguments里 且中间的状态 也要 在此切换(尽量)
页面 :  数据放在argments;数据持久到本地?;数据恢复;
请求防刷要写在在网络底层ActionTimer
请求结果要过滤 再显示否?持久化否?
一个模型 比如user,逻辑写到user一个地方
页面编程等 要考虑 懒加载还是先加载
--逻辑之间,方法之间要注意解耦:
逻辑不能调逻辑 网络请求里不能调用其他网络请求,应该另写一个方法 另写一个逻辑再在这个逻辑里组合这些逻辑
即逻辑只能组合 而不能相互调用!!
"逻辑之间不要互相调用,只能组合它们形成新的逻辑,方法之间不要相互 调用方法 而是 组合方法形成新的方法"


清空连接证书  cmd: net use *  /del /y
然后 可以用的账号密码:  1.dev - 111  2.test - 111
其中前者权限大


1.根activity的back键要拦截并且重定义为Home键功能
public boolean onKeyDown(int keyCode, KeyEvent event) {
		 
	if(keyCode == KeyEvent.KEYCODE_BACK && event.getAction() ==KeyEvent.ACTION_DOWN) {
			this.startActivity(new Intent(Intent.ACTION_MAIN).setFlags(Intent.FLAG_ACTIVITY_NEW_TASK).addCategory(Intent.CATEGORY_HOME));
			return true;
		}
		return super.onKeyDown(keyCode, event);
	}
2.需要重用的activity设为singleInstance 并且拦截他的 back键 重定义为要跳转到的activity
  
3.back键默认是要finish当前activity的
4.FLAG为FLAG_ACTIVITY_NEW_TASK的时候会查找是否与他本身有相同taskAffinity的task，如有则宿主到该task 否则 新建本身的taskAffinity 的task。
5.一个task为 home键右边任务栏的一个任务的选项卡（singleInstance除外），task之间可以互相叠加，重新排列
6.taskAffinity不设置则 一个application有一个task，所有activity都宿主到该task，task也有taskAffinity，默认值为根activity的taskAffinity，而根activity的taskAffinity默认为application的taskAffinity，application的taskAffinity未设置 则为 包名。
7.singleInstance的activity会新建task但是不会另建任务选项卡，现在模拟下面这种情况：
新建application，依次启动activity a、b、c 这时默认task堆栈《task是堆栈先进后出、队列是先进先出》为abc ,这时启动singleInstance 的activity d、 变成abcd 并且abc为默认task，d单独一个task，且该task有且仅有一个activity d。这时d startActivity 到 b， 这时会变成 dab《为什么会这样请看第5条》，d为一个task，ab为默认task，back键按2次会回到d， 但是你想想 a  activity是application的根activity通常是登入界面 或者 欢迎界面 而从a  back键后 居然回到 d！这会让用户感到奇怪。怎么处理？  看上面 第一条 重定义 a 的back键为home键 或者 a的back键 销毁所有。
///////////////////////////////////////////////////////////////////////////////////////////
/**
 * 1.activity创建view
 * 2.activity创建presenter<数据格式>(参数view)
 * 3.presenter在被创建的时候,即presenter的构造方法中持有了view,此时设置view持有本presenter,完成V-P的互相持有
 * 4.view要实现基view的多个方法,这里是 protected abstract int getContentViewLayoutID();//基view用来绑定布局文件
 * 和protected abstract void setViewCreated(@Nullable Bundle savedInstanceState);
 * //基view用来create view 并且要注意使用Bundle savedInstanceState恢复view
 * 5.view要实现基view(Interface)的多个方法,这里是 setProgressIndicator(boolean active)//被presenter在任务前回调
 * loadCompelete(Object O)//被presenter在任务完成时回调
 * loadError(int code, Exception e)//被presenter在任务出错时回调
 * setPresenter(BaseContract.Presenter presenter)//被view在创建时回调 用来持有一个presenter
 * 6.view 要重写android系统父view的onStart() 通过P启动task;  要重写android系统父view的onDestroyView() 销毁P
 * 7.Presenter 要实现基Presenter的多个方法 这里是  loadMore(boolean next)//被view在加载更多时回调
 * 和 start(Context appContext)//被view启动任务时回调
 * 和 destroy()//view被销毁时 回调销毁本presenter
 * 其他一些逻辑业务的方法  给view与用户交互时回调
 */


MVP进阶:
对象调用M
方法传递 都用对象做参数 并且该对象涉及到的逻辑的 引用都让该对象持有, 注意该对象只持有与数据 逻辑有关的东西 不持有view实例 或实例

ArrayList<ReceiptAddressBean> mReceiptAddressBeanList = new Gson().fromJson(response.get(Constant.Key.RESPONSE_OBJECTS).toString(),
                        new TypeToken<ArrayList<ReceiptAddressBean>>(){}.getType());